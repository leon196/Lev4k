// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef FRAGMENT_INL_
# define FRAGMENT_INL_

const char *fragment_frag =
 "#version 330\n"
 "#define m1 main\n"
 "uniform int m,pm;"
 "uniform sampler2D sb1;"
 "out vec4 o1;"
 "float v;"
 "vec2 d=vec2(1920,1080);"
 "vec2 s(float v)"
 "{"
   "vec3 s=fract(vec3(v)*vec3(.1031,.103,.0973));"
   "s+=dot(s,s.yzx+33.33);"
   "return fract((s.xx+s.yz)*s.zy);"
 "}"
 "vec2 t(vec3 v)"
 "{"
   "v=fract(v*vec3(.1031,.103,.0973));"
   "v+=dot(v,v.yzx+33.33);"
   "return fract((v.xx+v.yz)*v.zy);"
 "}"
 "float f(vec3 v)"
 "{"
   "return dot(sin(v),cos(v.yzx));"
 "}"
 "float n(vec3 v)"
 "{"
   "float x=0.,s=.5;"
   "for(int m=0;m<3;++m)"
     "x+=f(v/s)*s,s/=3.;"
   "return x;"
 "}"
 "vec2 e(float v)"
 "{"
   "vec2 f=vec2(0);"
   "float m=v*12.,o=.1,c=v*15.,x=floor(c);"
   "vec2 d=mix(s(x),s(x+1.),fract(c));"
   "f+=(d*2.-1.)*.5;"
   "f.x+=fract(v)*2.-1.;"
   "f+=vec2(cos(m),sin(m))*o;"
   "m=n(vec3(f,v))*6.28;"
   "o=.2;"
   "f+=vec2(cos(m),sin(m))*o;"
   "return f;"
 "}"
 "void m1()"
 "{"
   "v=m/44100.;"
   "vec2 f=(gl_FragCoord.xy-d.xy/2)/d.y,s=gl_FragCoord.xy/d.xy,c=t(vec3(gl_FragCoord.xy,m));"
   "vec3 o=vec3(0);"
   "float x=v*.2;"
   "f-=e(x+c.x*.01)*.5;"
   "float y=length(f)-.02+.01*sin(v*10.);"
   "o=(.5+.5*cos(vec3(1,2,3)*5.1+x*10.))*smoothstep(.01,0,y);"
   "o=max(o,texture(sb1,s).xyz*step(.01,fract(x)));"
   "o1=vec4(o,1);"
 "}"
 "void m2()"
 "{"
   "v=m/44100.;"
   "vec2 x=gl_FragCoord.xy/d.xy;"
   "vec3 f=vec3(0);"
   "vec2 s=vec2(.005,0);"
   "f.x+=texture(sb1,x-s).x;"
   "f.y+=texture(sb1,x).y;"
   "f.z+=texture(sb1,x+s).z;"
   "o1=vec4(f,1);"
 "}"
 "void m3()"
 "{"
   "vec2 v=gl_FragCoord.xy;"
   "float m=(v.x+v.y*1920)/44100.-.05;"
   "vec2 s=e(m*.2)*.5,f=vec2(0);"
   "float x=fract(m);"
   "f+=sin(440.*pow(2.,((4-4.)*12.+mod(floor(m),8))/12.)*6.283*x+s.y*1e2+sin(m*30))*exp(-x*3)*.7;"
   "o1=vec4(0,0,f);"
 "}";

#endif // FRAGMENT_INL_
